# SCON – Copilot instructions for AI coding agents

Purpose: make you productive fast in this repo. These are concrete, repo‑specific conventions and workflows.

## What this repo is
- A BepInEx mod for Stationeers exposing a small HTTP API to execute in‑game console commands and query basic state.
- Target framework: net472 (Unity/Mono). Key external deps: BepInEx 5.x, UnityEngine, Stationeers Assembly‑CSharp (via STATIONEERS_PATH).

## Architecture at a glance
- Entry: `Plugin` (`Plugin.cs`) – BepInEx plugin that reads config and starts the HTTP server.
- HTTP: `HttpServerManager` (`HttpServer.cs`) uses `HttpListener` on a background thread with CORS enabled and simple JSON responses.
- Threading: Requests enqueue work onto the Unity main thread via `UnityMainThreadDispatcher.Enqueue(Action)`. Never touch Unity/Stationeers objects off the main thread.
- Command execution: `CommandExecutor` reflects Stationeers’ console types and invokes a suitable method (e.g., `Submit(string)`), with fallbacks (instance discovery, SendMessage).
- Game info: `GameInfoCollector` reflects common types to infer server port/flags/world name; supports multiple Stationeers versions.
- Auto‑port bind: If dedicated server detected, SCON binds to `(server port + 1)` when `AutoBindToServerPortPlusOne = true`.

Data flow
```
HTTP (background thread) → Enqueue(Action) → UnityMainThreadDispatcher (main thread) → Reflection → Stationeers console
```

## Build, install, test
- Prereq: set `STATIONEERS_PATH` to the game root (contains `rocketstation_Data/Managed/Assembly-CSharp.dll`).
- Build (Windows PowerShell):
```powershell
$env:STATIONEERS_PATH = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Stationeers"
./build.ps1              # build Release
./build.ps1 -Install     # build and copy SCON.dll to BepInEx/plugins
```
- Test API against a running game:
```powershell
./test.ps1               # health, command, 404, CORS, JSON content-type
```
- Output DLL: `bin/Release/net472/SCON.dll`.

## Config and auth
- Config file: `BepInEx/config/SCON.cfg` (created on first run).
- Auth rules in `HttpServer.cs`:
  - If `ApiKey` empty: localhost requests allowed, non‑localhost denied.
  - If `ApiKey` set: require `Authorization: Bearer <key>` for all requests.

## Patterns to follow (with examples)
- Endpoints live in `HttpServerManager.HandleRequest(...)`. Use simple path checks and return JSON:
  - GET `/health` → `{ "status": "ok" }`
  - GET `/version` → versions + host/port (see `HandleVersionRequest`)
  - GET `/gameinfo` → JSON from `GameInfoCollector.GetGameInfo()`
  - POST `/command` → enqueue `CommandExecutor.ExecuteCommand(command)`
- Always set CORS headers: `Access-Control-Allow-Origin: *`, methods `POST, GET, OPTIONS`, headers `Content-Type, Authorization`. Reply 204 to OPTIONS.
- Always enqueue Unity work:
```csharp
UnityMainThreadDispatcher.Enqueue(() => CommandExecutor.ExecuteCommand(cmd));
```
- Keep responses JSON and small. Use the existing `JsonEscape` helpers when emitting strings.
- Reflection resilience: when adding/changing reflection, search multiple candidate type/method names and prefer safe null/exception handling; log with `Plugin.Log`.

## Conventions and gotchas
- Don’t block the main thread; all HTTP work is background except the enqueued action.
- Avoid adding JSON libraries—responses are manual/minimal for size and compatibility.
- Preserve `AutoBindToServerPortPlusOne` semantics: only apply when dedicated/server mode is detected (see `GameInfoCollector.TryGetServerPort`).
- Plugin metadata (`MyPluginInfo`) is generated by `BepInEx.PluginInfoProps`. Version comes from `<Version>` in `SCON.csproj` (also used in `/version`).
- When binding to `*`/`+`/`0.0.0.0`, Windows may require admin or URL ACLs; the server tries multiple prefixes and falls back to `127.0.0.1`.

## Common tasks
- Add a new read‑only endpoint:
  1) Add a branch in `HandleRequest` for the path; 2) build a small JSON string; 3) set `ContentType = application/json` and `StatusCode`.
- Execute a new command form:
  - Keep using `POST /command` with `{ "command": "..." }`. Command parsing is deliberately simple—avoid changing the contract.
- Extend game info:
  - Add robust reflection probes in `GameInfoCollector` (properties/fields, Instance patterns, and safe fallbacks). Don’t assume a single type name.

## File map
- `Plugin.cs` – entry point, config, start/stop, selects port.
- `HttpServer.cs` – listener, routing, CORS, auth, JSON responses.
- `CommandExecutor.cs` – console reflection, robust method discovery, main‑thread execution.
- `GameInfoCollector.cs` – server port/server flag/world name discovery with fallbacks.
- `UnityMainThreadDispatcher.cs` – queue and run actions on Unity main thread.
- Scripts: `build.ps1`, `test.ps1`, `examples.ps1`.

If anything here doesn’t match current behavior, prefer the code in the files above and update this doc accordingly.